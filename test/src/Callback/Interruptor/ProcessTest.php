<?php

namespace zaboy\test\Interruptor\Callback;

use zaboy\Callback\Callback;
use zaboy\test\Callback\Interruptor\CallbackTestCallableProvider;
use zaboy\async\Promise\Promise;
use zaboy\Callback\Interruptor\Process;
use zaboy\Di\InsideConstruct;
use zaboy\test\Callback\CallbackTest;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-10-13 at 12:52:54.
 */
class ProcessTest extends CallbackTestCallableProvider
{

    protected function setUp()
    {
        $container = include 'config/container.php';
        InsideConstruct::setContainer($container);
    }

    /**
     * @covers zaboy\Callback\Callback::__wakeup
     * @dataProvider provider_mainType()
     */
    public function test__wakeupWithPromise($callable, $val, $expected)
    {
        $callback = new Callback($callable);
        $wakeupedCallback = unserialize(serialize($callback));
        $masterPromise = new Promise();
        $slavePromise = $masterPromise->then($wakeupedCallback);
        $interruptorProcess = new Process([$masterPromise, 'resolve']);
        $result = $interruptorProcess($val);
        $this->assertEquals($expected, $slavePromise->wait(true));
        $this->assertFileExists($result[Process::STDOUT_KEY]);
        $this->assertFileExists($result[Process::STDERR_KEY]);

        if (substr(php_uname(), 0, 7) === "Windows") {
            $this->assertEquals('', $result[Process::PID_KEY]);
        } else {
            $this->assertNotSame('', $result[Process::PID_KEY]);
        }
    }

//
//    public function test__wakeupWithPromiseParallels()
//    {
//
//        $callback = new Callback(function ( $val) {
//            sleep(1);
//            $resultMasterPromise = new Promise;
//            $interruptorProcess = new Process([$resultMasterPromise, 'resolve']);
//            $resultSlavePromise = $resultMasterPromise->then('microtime'); //microtime(1)
//            $interruptorProcess($val);
//            return $resultSlavePromise;
//        });
//
//        $masterPromise = new Promise();
//        $slavePromise_1 = $masterPromise->then($callback);
//        $slavePromise_2 = $masterPromise->then($callback);
//
//        $masterPromise->resolve(1); //in sec
//        exit;
//        var_dump($slavePromise_1->getState());
//        var_dump($slavePromise_2->getState());
//
//        if (abs($slavePromise_1->wait(2) - $slavePromise_2->wait(2)) < 0.5) {
//            $result = 'parallel';
//        } else {
//            $result = 'in series';
//        }
//
//        if (substr(php_uname(), 0, 7) === "Windows") {
//            $this->assertEquals('in series', $result);
//        } else {
//            $this->assertNotSame('parallel', $result);
//        }
//    }
}
